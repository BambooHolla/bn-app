// This file is auto generated by the protocol-buffers cli tool

/* eslint-disable quotes */
/* eslint-disable indent */
/* eslint-disable no-redeclare */
/* eslint-disable camelcase */

// Remember to `npm install --save protocol-buffers-encodings`
var encodings = require('protocol-buffers-encodings')
var varint = encodings.varint
var skip = encodings.skip

var SimpleBlock = exports.SimpleBlock = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var PackList = exports.PackList = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

defineSimpleBlock()
definePackList()

function defineSimpleBlock () {
  var enc = [
    encodings.int32,
    encodings.int64,
    encodings.bytes
  ]

  SimpleBlock.encodingLength = encodingLength
  SimpleBlock.encode = encode
  SimpleBlock.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (!defined(obj.version)) throw new Error("version is required")
    var len = enc[0].encodingLength(obj.version)
    length += 1 + len
    if (!defined(obj.timestamp)) throw new Error("timestamp is required")
    var len = enc[0].encodingLength(obj.timestamp)
    length += 1 + len
    if (!defined(obj.totalAmount)) throw new Error("totalAmount is required")
    var len = enc[1].encodingLength(obj.totalAmount)
    length += 1 + len
    if (!defined(obj.totalFee)) throw new Error("totalFee is required")
    var len = enc[1].encodingLength(obj.totalFee)
    length += 1 + len
    if (!defined(obj.reward)) throw new Error("reward is required")
    var len = enc[1].encodingLength(obj.reward)
    length += 1 + len
    if (!defined(obj.numberOfTransactions)) throw new Error("numberOfTransactions is required")
    var len = enc[0].encodingLength(obj.numberOfTransactions)
    length += 1 + len
    if (!defined(obj.payloadLength)) throw new Error("payloadLength is required")
    var len = enc[0].encodingLength(obj.payloadLength)
    length += 1 + len
    if (!defined(obj.payloadHash)) throw new Error("payloadHash is required")
    var len = enc[2].encodingLength(obj.payloadHash)
    length += 1 + len
    if (!defined(obj.generatorPublicKey)) throw new Error("generatorPublicKey is required")
    var len = enc[2].encodingLength(obj.generatorPublicKey)
    length += 1 + len
    if (defined(obj.blockSignature)) {
      var len = enc[2].encodingLength(obj.blockSignature)
      length += 1 + len
    }
    if (defined(obj.previousBlock)) {
      var len = enc[2].encodingLength(obj.previousBlock)
      length += 1 + len
    }
    if (defined(obj.id)) {
      var len = enc[2].encodingLength(obj.id)
      length += 1 + len
    }
    if (defined(obj.height)) {
      var len = enc[1].encodingLength(obj.height)
      length += 1 + len
    }
    if (defined(obj.blockSize)) {
      var len = enc[0].encodingLength(obj.blockSize)
      length += 1 + len
    }
    if (defined(obj.remark)) {
      var len = enc[2].encodingLength(obj.remark)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (!defined(obj.version)) throw new Error("version is required")
    buf[offset++] = 8
    enc[0].encode(obj.version, buf, offset)
    offset += enc[0].encode.bytes
    if (!defined(obj.timestamp)) throw new Error("timestamp is required")
    buf[offset++] = 16
    enc[0].encode(obj.timestamp, buf, offset)
    offset += enc[0].encode.bytes
    if (!defined(obj.totalAmount)) throw new Error("totalAmount is required")
    buf[offset++] = 24
    enc[1].encode(obj.totalAmount, buf, offset)
    offset += enc[1].encode.bytes
    if (!defined(obj.totalFee)) throw new Error("totalFee is required")
    buf[offset++] = 32
    enc[1].encode(obj.totalFee, buf, offset)
    offset += enc[1].encode.bytes
    if (!defined(obj.reward)) throw new Error("reward is required")
    buf[offset++] = 40
    enc[1].encode(obj.reward, buf, offset)
    offset += enc[1].encode.bytes
    if (!defined(obj.numberOfTransactions)) throw new Error("numberOfTransactions is required")
    buf[offset++] = 48
    enc[0].encode(obj.numberOfTransactions, buf, offset)
    offset += enc[0].encode.bytes
    if (!defined(obj.payloadLength)) throw new Error("payloadLength is required")
    buf[offset++] = 56
    enc[0].encode(obj.payloadLength, buf, offset)
    offset += enc[0].encode.bytes
    if (!defined(obj.payloadHash)) throw new Error("payloadHash is required")
    buf[offset++] = 66
    enc[2].encode(obj.payloadHash, buf, offset)
    offset += enc[2].encode.bytes
    if (!defined(obj.generatorPublicKey)) throw new Error("generatorPublicKey is required")
    buf[offset++] = 74
    enc[2].encode(obj.generatorPublicKey, buf, offset)
    offset += enc[2].encode.bytes
    if (defined(obj.blockSignature)) {
      buf[offset++] = 82
      enc[2].encode(obj.blockSignature, buf, offset)
      offset += enc[2].encode.bytes
    }
    if (defined(obj.previousBlock)) {
      buf[offset++] = 90
      enc[2].encode(obj.previousBlock, buf, offset)
      offset += enc[2].encode.bytes
    }
    if (defined(obj.id)) {
      buf[offset++] = 98
      enc[2].encode(obj.id, buf, offset)
      offset += enc[2].encode.bytes
    }
    if (defined(obj.height)) {
      buf[offset++] = 104
      enc[1].encode(obj.height, buf, offset)
      offset += enc[1].encode.bytes
    }
    if (defined(obj.blockSize)) {
      buf[offset++] = 112
      enc[0].encode(obj.blockSize, buf, offset)
      offset += enc[0].encode.bytes
    }
    if (defined(obj.remark)) {
      buf[offset++] = 122
      enc[2].encode(obj.remark, buf, offset)
      offset += enc[2].encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      version: 0,
      timestamp: 0,
      totalAmount: 0,
      totalFee: 0,
      reward: 0,
      numberOfTransactions: 0,
      payloadLength: 0,
      payloadHash: null,
      generatorPublicKey: null,
      blockSignature: null,
      previousBlock: null,
      id: null,
      height: 0,
      blockSize: 0,
      remark: null
    }
    var found0 = false
    var found1 = false
    var found2 = false
    var found3 = false
    var found4 = false
    var found5 = false
    var found6 = false
    var found7 = false
    var found8 = false
    while (true) {
      if (end <= offset) {
        if (!found0 || !found1 || !found2 || !found3 || !found4 || !found5 || !found6 || !found7 || !found8) throw new Error("Decoded message is not valid")
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.version = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        found0 = true
        break
        case 2:
        obj.timestamp = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        found1 = true
        break
        case 3:
        obj.totalAmount = enc[1].decode(buf, offset)
        offset += enc[1].decode.bytes
        found2 = true
        break
        case 4:
        obj.totalFee = enc[1].decode(buf, offset)
        offset += enc[1].decode.bytes
        found3 = true
        break
        case 5:
        obj.reward = enc[1].decode(buf, offset)
        offset += enc[1].decode.bytes
        found4 = true
        break
        case 6:
        obj.numberOfTransactions = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        found5 = true
        break
        case 7:
        obj.payloadLength = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        found6 = true
        break
        case 8:
        obj.payloadHash = enc[2].decode(buf, offset)
        offset += enc[2].decode.bytes
        found7 = true
        break
        case 9:
        obj.generatorPublicKey = enc[2].decode(buf, offset)
        offset += enc[2].decode.bytes
        found8 = true
        break
        case 10:
        obj.blockSignature = enc[2].decode(buf, offset)
        offset += enc[2].decode.bytes
        break
        case 11:
        obj.previousBlock = enc[2].decode(buf, offset)
        offset += enc[2].decode.bytes
        break
        case 12:
        obj.id = enc[2].decode(buf, offset)
        offset += enc[2].decode.bytes
        break
        case 13:
        obj.height = enc[1].decode(buf, offset)
        offset += enc[1].decode.bytes
        break
        case 14:
        obj.blockSize = enc[0].decode(buf, offset)
        offset += enc[0].decode.bytes
        break
        case 15:
        obj.remark = enc[2].decode(buf, offset)
        offset += enc[2].decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function definePackList () {
  var enc = [
    encodings.bytes
  ]

  PackList.encodingLength = encodingLength
  PackList.encode = encode
  PackList.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.list)) {
      for (var i = 0; i < obj.list.length; i++) {
        if (!defined(obj.list[i])) continue
        var len = enc[0].encodingLength(obj.list[i])
        length += 1 + len
      }
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.list)) {
      for (var i = 0; i < obj.list.length; i++) {
        if (!defined(obj.list[i])) continue
        buf[offset++] = 10
        enc[0].encode(obj.list[i], buf, offset)
        offset += enc[0].encode.bytes
      }
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      list: []
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.list.push(enc[0].decode(buf, offset))
        offset += enc[0].decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defined (val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))
}
